<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Pod::Advent 0.14 (Pod::Simple 3.07, Perl::Tidy 20031021) on 2008-12-20 16:58:36 -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>2008 Perl Advent Calendar: 'Tis the season to tie one on</title>
<link rel="stylesheet" href="../style.css" type="text/css" />
<link rel="alternate" type="text/plain" href="mod20.pod" />
</head>
<body>
<h1><a href="../">Perl Advent Calendar 2008-12</a>-19+20</h1>
<h2 align="center">'Tis the season to tie one on</h2>
<h3 align="center">by Jerrad Pierce</h3>
<blockquote>Three modules for the price of two, to make up for the lag.</blockquote>
<p>Santa's terrible with names and spelling, why do you think he keeps all those lists? Eventually even this saint grew impatient with his computer's inability to do what he meant, just because he added an extra S or left off a silent H in some kids name, so he tried some of the solutions on CPAN but none met his exacting standards; it's all black or white with this guy! Not afraid to (re)invent the wheel he rolled his own with three other helpful libraries from the respository, and created a simple tied hash that was forgiving of false figuration and fat finger syndrome.<sup><a href="#footnote_fxn">1</a></sup></p>
<h2><tt><a href="http://search.cpan.org/perldoc?Tie::OneOff">Tie::OneOff</a></tt></h2>
<p><tt>Tie::OneOff</tt> provides several mechanisms for implementing <tt><span class="k">tie</span></tt>-d interfaces without extraneous files or packages. All follow the same premise of the user providing an explicit hash(ref) for use as a variable accesor method dispatch table (lines 7&ndash;18), rather than class methods in another package. Something similar could be achieved through the use of <tt><span class="k">AUTOLOAD</span></tt> but if you're going to use syntactic sugar, why not go for as short and sweet as possible?</p>
<h2><tt><a href="http://search.cpan.org/perldoc?Text::Metaphone">Text::Metaphone</a></tt></h2>
<p>You may be familiar with Soundex, a nearly century-old method of comparing surnames. A simple and ready standby, Soundex maps a string into a space of 56_862 buckets denoted by a four-character string, resulting in a number of collisions. Metaphone on the other hand, offers an infinite digest space since its hashes are variable width. Both ignore vowels, but besides not truncating results, Metaphone also takes account of digraphs and trigraphs in its mapping. By default, this implementation deviates from the original and maps certain cases of <span style="font-style: italic">SCH</span> to "sh" or <span style="font-style: italic">X</span> so that the author's name is correctly encoded. Unfortunately some other cases are missed, so a common misspelling of Schmidt is encoded differently:</p>
<pre>  % perl -MText::Metaphone -le 'print Metaphone($_) for qw/Schmidt Shmidt/'<span class="c">
  SKMTT
  XMTT</span></pre>
<h2><tt><a href="http://search.cpan.org/perldoc?String::Approx">String::Approx</a></tt></h2>
<p>In order to ensure that homophones such as Schmidt, Schmitt, Shmidt and Shmitt are not unnecessarily perceived as distinct, Santa made use of <tt>String::Approx</tt>. With it, even though each has a different Metaphonic hash,</p>
<pre><span class="c">SKMTT
SKMT
XMTT
XMT</span></pre>
<p><a href="http://en.wikipedia.org/wiki/John_Jacob_Jingleheimer_Schmidt">John Jacob Jingleheimer</a>'ll get his Speak &amp; Spell&trade; no matter how his last name is spelled; as long as we relax the matching criteria from the default 10% difference on Line 14 to catch Shmitt.</p>
<a name="mod20.pl" id="mod20.pl"></a><h2><a href="mod20.pl">mod20.pl</a></h2><pre>
   1 <span class="k">use</span> <span class="w">Tie::OneOff</span><span class="sc">;</span>
   2 <span class="k">use</span> <span class="w">Text::Metaphone</span><span class="sc">;</span>
   3 <span class="k">use</span> <span class="w">String::Approx</span> <span class="q">'amatch'</span><span class="sc">;</span>
   4 
   5 <span class="k">tie</span> <span class="k">my</span> <span class="i">%ahash</span><span class="cm">,</span> <span class="q">'Tie::OneOff'</span><span class="cm">,</span> <span class="k">do</span><span class="s">{</span>
   6   <span class="k">my</span> <span class="i">%_hash</span><span class="cm">,</span> <span class="c">#Private stash w/o a closure</span>
   7     <span class="s">{</span>
   8      <span class="w">BASE</span>  <span class="cm">=&gt;</span> \<span class="i">%_hash</span><span class="cm">,</span>
   9      <span class="w">FETCH</span> <span class="cm">=&gt;</span> <span class="k">sub</span> <span class="s">{</span>
  10        <span class="k">my</span> <span class="i">$key</span> = <span class="k">shift</span><span class="sc">;</span>
  11        <span class="k">return</span> <span class="k">undef</span> <span class="k">unless</span> <span class="i">%_hash</span><span class="sc">;</span>
  12        <span class="k">return</span> <span class="i">$_hash</span>{<span class="i">$key</span>} <span class="k">if</span> <span class="k">exists</span> <span class="i">$_hash</span>{<span class="i">$key</span>}<span class="sc">;</span>
  13        <span class="k">my</span> <span class="i">%real</span> = <span class="k">map</span><span class="s">{</span> <span class="i">Metaphone</span><span class="s">(</span><span class="i">$_</span><span class="s">)</span><span class="cm">=&gt;</span><span class="i">$_</span> <span class="s">}</span> <span class="k">keys</span> <span class="i">%_hash</span><span class="sc">;</span>
  14        <span class="k">my</span> <span class="i">@like</span> = <span class="i">amatch</span><span class="s">(</span><span class="i">Metaphone</span><span class="s">(</span><span class="i">$key</span><span class="s">)</span><span class="cm">,</span> <span class="s">[</span><span class="q">'15%'</span><span class="s">]</span><span class="cm">,</span> <span class="k">keys</span> <span class="i">%real</span><span class="s">)</span><span class="sc">;</span>
  15        <span class="k">return</span> <span class="i">@like</span> ? <span class="i">$_hash</span>{ <span class="i">$real</span>{<span class="i">$like</span>[<span class="n">0</span>]} } <span class="co">:</span> <span class="k">undef</span><span class="sc">;</span>
  16      <span class="s">}</span><span class="cm">,</span>
  17      <span class="w">STORE</span> <span class="cm">=&gt;</span> <span class="k">sub</span> <span class="s">{</span> <span class="i">$_hash</span>{<span class="i">$_</span>[<span class="n">0</span>]} = <span class="i">$_</span>[<span class="n">1</span>] <span class="s">}</span>
  18     <span class="s">}</span>
  19   <span class="s">}</span><span class="sc">;</span>
  20 
  21 <span class="i">@ahash</span>{<span class="q">'Jerrad Pierce'</span><span class="cm">,</span> <span class="q">'John Jacob Jingleheimer Schmidt'</span>} =
  22       <span class="s">(</span><span class="q">'Snowpeak titanium sporks'</span><span class="cm">,</span> <span class="q">'Speak &amp; Spell'</span><span class="s">)</span><span class="sc">;</span>
  23 
  24 <span class="k">print</span> <span class="k">join</span><span class="s">(</span><span class="q">&quot;\n&quot;</span><span class="cm">,</span> <span class="i">@ahash</span>{<span class="q">'Jarad Pearse'</span><span class="cm">,</span> <span class="q">'Jon Jacob Jinglehiemer Schmitt'</span>}<span class="cm">,</span> <span class="q">''</span><span class="s">)</span><span class="sc">;</span>
  25 <span class="c">#Snowpeak titanium sporks</span>
  26 <span class="c">#Speak &amp; Spell</span>
</pre>
<p><a name="footnote_fxn" id="footnote_fxn"></a>1. Rather than employ the Metaphone hash as the key in its private data store, Santa's code preserves keys and only seeks similar indexes if an exact match is not found. This approach reduces collisions, and is most appropriate if the hash has been populated with an authoritative source.</p>
<div style="float: right; font-size: 10pt"><a href="mod20.pod">View Source (POD)</a></div><br />
</body>
</html>
